import RPi.GPIO as GPIO
import logging
from RpiMotorLib import RpiMotorLib
import time

logger = logging.getLogger(__name__)


class RobotController:
    def __init__(self, DIR_PINS: dict = {"MOTOR_Z": 20, "MOTOR_X": 26},
                 STEP_PINS: dict = {"MOTOR_Z": 21, "MOTOR_X": 19},
                 END_STOP_PINS: dict = {"MOTOR_Z": 0, "MOTOR_X": 0},
                 MICROSTEP_RES_PINS: tuple = (14, 15, 18),
                 RELAY_PIN: int = 6,
                 ENDSTOP_PIN: int = 22):

        self.DIR_PINS = DIR_PINS
        self.STEP_PINS = STEP_PINS
        self.MICROSTEP_RES_PINS = MICROSTEP_RES_PINS
        self.RELAY_PIN = RELAY_PIN
        self.ENDSTOP_PIN = ENDSTOP_PIN
        self.END_STOP_PINS = END_STOP_PINS
        self.relay_state = None
        self.MOTORS = dict()
        self.initialize_controller()

    def initialize_controller(self):
        for key in self.STEP_PINS.keys():
            self.MOTORS[key] = RpiMotorLib.A4988Nema(
                self.DIR_PINS[key], self.STEP_PINS[key], self.MICROSTEP_RES_PINS, "DRV8825")
            logger.info(f'Initialized {key}')

        GPIO.setmode(GPIO.BCM)
        GPIO.setup(self.RELAY_PIN, GPIO.OUT)
        logger.info(f'Initialized relay on PIN {self.RELAY_PIN}')

        for key in self.END_STOP_PINS:
            GPIO.setup(self.END_STOP_PINS[key],
                       GPIO.IN, pull_up_down=GPIO.PUD_DOWN)
            GPIO.add_event_callback(
                self.END_STOP_PINS[key], edge=GPIO.RISING, bouncetime=500)
            logger.info(
                f'Initialized endstops on PIN {self.END_STOP_PINS[key]}')


    def run_motor(self, motor: str, clockwise: bool = False, steptype: str = 'Full',
                  steps: int = 100, step_delay: float = 0.005):
        GPIO.output(self.RELAY_PIN, GPIO.HIGH)

        self.MOTORS[motor].motor_go(clockwise=clockwise, steptype=steptype,
                                    steps=steps, stepdelay=step_delay, verbose=False, initdelay=.05)

        GPIO.output(self.RELAY_PIN, GPIO.LOW)

    def home_all(self):
        for motor, END_STOP_PIN in self.END_STOP_PINS.items():
            self.home(motor,END_STOP_PIN)

    def home(self, motor: str, END_STOP_PIN: int):
        while not GPIO.event_detected(END_STOP_PIN):
            self.run_motor(motor=motor, steps=5)
            time.sleep(0.05)
        logger.info(f'Endstop {END_STOP_PIN} for {motor} reached!')


if __name__ == '__main__':
    controller = RobotController()
    controller.run_motor(motor='MOTOR_X',
                         steps=200)
